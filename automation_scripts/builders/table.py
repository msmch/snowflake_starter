import pandas as pd
from .base import BaseBuilder


class TableBuilder(BaseBuilder):
    """
    Class that helps us build the basic table DDL. It inspects a Pandas DataFrame to determine column data types 
    and nullable constraints.
    
    The file generated by this class needs some manual effort however most of the code is already there.

    NEVER use this automation class for dynamical SQL composition in PROD application. It's supposed to automate the warehouse 
    creation and using the f-string approach in dynamic SQL composition is extremely dangerous because it's exposing your code 
    to SQL Injections. For that purpose check ORM, like Snowpark or SQLAlchemy.
    """

    def __init__(self, df: pd.DataFrame) -> None:
        super().__init__()
        self.df = df

    # note it's not changing memory usage, you can go ahead and assign 250 to all
    @staticmethod
    def round_up_to_nearest(value):
        rounding_values = [10, 20, 30, 40, 50, 100, 150, 250]
        rounded_value = min(rounding_values, key=lambda x: abs(x - value) if x > value else 1000)
        if rounded_value > value:
            return rounded_value 
        else:
            return value

    def varchar_cols_length(self, offset: int = 10) -> dict:
        varchar_cols = {}
        for col in self.df.columns: 
            if self.df[col].dtype == object:
                chars = self.df[col].fillna('').apply(lambda x: len(x)).max() 
                chars = self.round_up_to_nearest(chars + offset)
                varchar_cols[col] = chars
        return varchar_cols

    def is_nullable(self, col: str) -> bool:
        if self.df[col].isnull().sum() > 0:
            return True
        else:
            return False
    
    def is_categorical(self, col: str, limit: int = 10) -> bool:
        val_counts = self.df[col].value_counts()
        if len(val_counts) <= limit:
            return True
        else:
            return False

    def data_type(self, col: str) -> str:
        dtype = self.df[col].dtype
        if dtype == object:
            return 'varchar'
        if dtype in ['int16', 'int32', 'int64']:
            return 'int'
        if dtype in ['float16', 'float32', 'float64']:
            return 'float'
        
    def add_or_edit_timestamp_col(self, sql: str, add_timestamp: bool = True) -> str:
        if add_timestamp:
            return sql + f'{self.ident}add_timestamp timestamp default current_timestamp(),\n'
        return sql + f'{self.ident}edit_timestamp timestamp\n);'

    def build_statment(
            self, 
            table_name: str,
            db_name: str|None = None,
            schema_name: str|None = None
    ) -> str:
        cols_length = self.varchar_cols_length()

        sql = f'create table {table_name}(\n'
        for col in self.df.columns:
            dtype = self.data_type(col)
            if dtype == 'varchar':
                dtype = f'{dtype}({cols_length[col]})'

            optional = ''
            if not self.is_nullable(col):
                optional = ' not null'

            sql += f'    {col} {dtype}{optional},\n'

        sql = self.add_or_edit_timestamp_col(sql, add_timestamp=True)
        sql = self.add_or_edit_timestamp_col(sql, add_timestamp=False)

        sql = self.prettify_statement(
            sql,
            specify_db_schema=True,
            db_name=db_name or self.core_database,
            schema_name=schema_name or self.staging_schema
        )
        return sql
