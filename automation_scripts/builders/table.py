import logging
import pandas as pd
from .base import BaseBuilder

import sys
sys.path.append('../')
from utils.basic import convert_date_columns


class TableBuilder(BaseBuilder):
    """
    Class that helps us build the basic table DDL. It inspects a Pandas DataFrame to determine column data types 
    and nullable constraints.
    
    The file generated by this class needs some manual effort however most of the code is already there.

    NEVER use this automation class for dynamical SQL composition in PROD application. It's supposed to automate the warehouse 
    creation and using the f-string approach in dynamic SQL composition is extremely dangerous because it's exposing your code 
    to SQL Injections. For that purpose check ORM, like Snowpark or SQLAlchemy.
    """

    def __init__(self, df: pd.DataFrame) -> None:
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.df = convert_date_columns(df)

    def varchar_cols_length(self, default_chars: int = 255) -> dict:
        varchar_cols = {}
        for col in self.df.columns: 
            if self.df[col].dtype == object:
                chars = self.df[col].fillna('').apply(lambda x: len(x)).max() 
                varchar_cols[col] = max(chars, default_chars)
        return varchar_cols

    def is_nullable(self, col: str) -> bool:
        if self.df[col].isnull().sum() > 0:
            return True
        else:
            return False
    
    def is_categorical(self, col: str, limit: int = 10) -> bool:
        val_counts = self.df[col].value_counts()
        if len(val_counts) <= limit:
            return True
        else:
            return False

    def data_type(self, col: str) -> str:
        dtype = self.df[col].dtype
        self.logger.debug(f"     {col}: {dtype}")
        if dtype == object:
            return 'varchar'
        if dtype == 'datetime64[ns]':
            return 'date'
        if dtype in ['int16', 'int32', 'int64']:
            return 'int'
        if dtype in ['float16', 'float32', 'float64']:
            return 'float'
        
    def add_or_edit_timestamp_col(self, sql: str, add_timestamp: bool = True) -> str:
        if add_timestamp:
            return sql + f'{self.ident}add_timestamp timestamp default current_timestamp(),\n'
        return sql + f'{self.ident}edit_timestamp timestamp\n);'

    def build_statment(
            self, 
            table_name: str,
            db_name: str|None = None,
            schema_name: str|None = None
    ) -> str:
        cols_length = self.varchar_cols_length()

        sql = f'create table {table_name}(\n'
        self.logger.debug("Analysing data types of the dataframe columns.")
        for col in self.df.columns:
            dtype = self.data_type(col)
            if dtype == 'varchar':
                dtype = f'{dtype}({cols_length[col]})'

            optional = ''
            if not self.is_nullable(col):
                optional = ' not null'

            sql += f'    {col} {dtype}{optional},\n'

        sql = self.add_or_edit_timestamp_col(sql, add_timestamp=True)
        sql = self.add_or_edit_timestamp_col(sql, add_timestamp=False)

        sql = self.prettify_statement(
            sql,
            specify_db_schema=True,
            db_name=db_name or self.core_database,
            schema_name=schema_name or self.staging_schema
        )
        return sql
